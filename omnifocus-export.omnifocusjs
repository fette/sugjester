/*{
    "type": "action",
    "targets": ["omnifocus"],
    "author": "William's Sugjester",
    "identifier": "com.sugjester.export-books",
    "version": "1.0",
    "description": "Exports English and Japanese book consideration lists to JSON for Sugjester",
    "label": "Export Books for Sugjester",
    "shortLabel": "Export Books",
    "paletteLabel": "Export Books",
    "image": "books.vertical"
}*/

(() => {
    const action = new PlugIn.Action(async function(selection, sender){
        try {
            // Define the output directory - adjust this path as needed
            const outputDir = "/Users/fet/source/sugjester/data/";
            
            // Create the data directory if it doesn't exist
            const fileManager = FileManager.local;
            if (!fileManager.directoryExists(outputDir)) {
                fileManager.createDirectory(outputDir);
            }
            
            // Function to export books by project ID
            function exportBooksByProject(projectId, projectName, filename, language) {
                let project;
                try {
                    // Parse the project ID from the omnifocus:/// URL
                    const idMatch = projectId.match(/project\/([^\/]+)/);
                    if (!idMatch) {
                        console.log(`Warning: Invalid project ID format: ${projectId}`);
                        return { language: language, count: 0, filePath: "" };
                    }
                    
                    const id = idMatch[1];
                    project = flattenedProjects.byIdentifier(id);
                    
                    if (!project) {
                        console.log(`Warning: Project with ID '${id}' not found`);
                        return { language: language, count: 0, filePath: "" };
                    }
                } catch (error) {
                    console.log(`Error finding project: ${error.message}`);
                    return { language: language, count: 0, filePath: "" };
                }
                
                const tasks = project.task.flattenedTasks.filter(task => !task.completed);
                const bookData = tasks.map(task => {
                    // Extract additional metadata from task notes or tags
                    let priority = "normal";
                    let bucketName = projectName;
                    
                    // Check for high-priority markers
                    if (task.name.includes("⭐️") || task.name.includes("@high-priority")) {
                        priority = "high";
                    }
                    
                    // Clean up task name (remove priority markers)
                    let cleanName = task.name
                        .replace(/⭐️/g, '')
                        .replace(/@high-priority/g, '')
                        .trim();
                    
                    return {
                        title: cleanName,
                        project: projectName,
                        bucket: bucketName,
                        priority: priority,
                        dateAdded: task.added.toISOString(),
                        notes: task.note || "",
                        tags: task.tags.map(t => t.name),
                        deferDate: task.deferDate ? task.deferDate.toISOString() : null,
                        dueDate: task.dueDate ? task.dueDate.toISOString() : null,
                        projectId: projectId
                    };
                });
                
                // Group by bucket/project for better organization
                const groupedData = {};
                bookData.forEach(book => {
                    if (!groupedData[book.bucket]) {
                        groupedData[book.bucket] = [];
                    }
                    groupedData[book.bucket].push(book);
                });
                
                const exportData = {
                    language: language,
                    exportDate: new Date().toISOString(),
                    totalBooks: bookData.length,
                    buckets: groupedData,
                    flatList: bookData,
                    sourceProject: {
                        name: projectName,
                        id: projectId
                    }
                };
                
                // Write to file
                const filePath = outputDir + filename;
                fileManager.writeString(filePath, JSON.stringify(exportData, null, 2));
                
                return {
                    language: exportData.language,
                    count: bookData.length,
                    filePath: filePath
                };
            }
            
            // Export from specific OmniFocus projects
            const projectIds = {
                booksToConsider: "omnifocus:///project/aCuCB0X3CYn",
                booksOwnedToRead: "omnifocus:///project/gipgWMqDMdb", 
                japaneseBooksToConsider: "omnifocus:///project/bPvbY14zt9G"
            };
            
            // Export individual projects first
            const booksToConsiderResult = exportBooksByProject(
                projectIds.booksToConsider,
                "Books to consider", 
                "books-to-consider.json",
                "english"
            );
            
            const booksOwnedResult = exportBooksByProject(
                projectIds.booksOwnedToRead,
                "Books owned to read",
                "books-owned-to-read.json", 
                "english"
            );
            
            const japaneseResult = exportBooksByProject(
                projectIds.japaneseBooksToConsider,
                "Japanese books to consider",
                "japanese-books-to-consider.json",
                "japanese"
            );
            
            // Combine English projects into single export
            let combinedEnglishBooks = [];
            let englishBuckets = {};
            
            // Read the individual files and combine them
            try {
                if (booksToConsiderResult.count > 0) {
                    const considerData = JSON.parse(fileManager.readString(outputDir + "books-to-consider.json"));
                    combinedEnglishBooks = combinedEnglishBooks.concat(considerData.flatList);
                    Object.assign(englishBuckets, considerData.buckets);
                }
                
                if (booksOwnedResult.count > 0) {
                    const ownedData = JSON.parse(fileManager.readString(outputDir + "books-owned-to-read.json"));
                    combinedEnglishBooks = combinedEnglishBooks.concat(ownedData.flatList);
                    Object.assign(englishBuckets, ownedData.buckets);
                }
                
                // Create combined English export
                const combinedEnglishData = {
                    language: "english",
                    exportDate: new Date().toISOString(),
                    totalBooks: combinedEnglishBooks.length,
                    buckets: englishBuckets,
                    flatList: combinedEnglishBooks,
                    sourceProjects: [
                        { name: "Books to consider", id: projectIds.booksToConsider },
                        { name: "Books owned to read", id: projectIds.booksOwnedToRead }
                    ]
                };
                
                fileManager.writeString(outputDir + "english-books-to-consider.json", 
                                      JSON.stringify(combinedEnglishData, null, 2));
                                      
                // Clean up individual files
                if (fileManager.fileExists(outputDir + "books-to-consider.json")) {
                    fileManager.deleteItem(outputDir + "books-to-consider.json");
                }
                if (fileManager.fileExists(outputDir + "books-owned-to-read.json")) {
                    fileManager.deleteItem(outputDir + "books-owned-to-read.json");
                }
                
                var englishResult = {
                    language: "english",
                    count: combinedEnglishBooks.length,
                    filePath: outputDir + "english-books-to-consider.json"
                };
                
            } catch (error) {
                console.error("Error combining English projects:", error);
                var englishResult = {
                    language: "english", 
                    count: 0,
                    filePath: ""
                };
            }
            
            // Create summary report
            const summary = {
                exportDate: new Date().toISOString(),
                results: {
                    english: englishResult,
                    japanese: japaneseResult
                },
                sourceProjects: {
                    "Books to consider": projectIds.booksToConsider,
                    "Books owned to read": projectIds.booksOwnedToRead,
                    "Japanese books to consider": projectIds.japaneseBooksToConsider
                }
            };
            
            const summaryPath = outputDir + "export-summary.json";
            fileManager.writeString(summaryPath, JSON.stringify(summary, null, 2));
            
            // Show results to user
            const totalBooks = summary.results.english.count + summary.results.japanese.count;
            const alertMsg = `Export Complete!\n\n` +
                           `English books: ${summary.results.english.count}\n` +
                           `Japanese books: ${summary.results.japanese.count}\n` +
                           `Total: ${totalBooks} books\n\n` +
                           `Files saved to:\n${outputDir}`;
            
            new Alert("Sugjester Export", alertMsg).show();
            
        } catch (error) {
            new Alert("Export Error", `Failed to export books: ${error.message}`).show();
            console.error("Export error:", error);
        }
    });

    action.validate = function(selection, sender){
        return true;
    };

    return action;
})();
